import type { TSESTree } from '@typescript-eslint/utils';

import type {
  IssueLocation,
} from '../utils/locations';

import { getJsxShortCircuitNodes } from '../utils/jsx';
import {
  getFirstToken,
  getFirstTokenAfter,
  getMainFunctionTokenLocation,
  issueLocation,
  report,
} from '../utils/locations';
import { isArrowFunctionExpression, isIfStatement, isLogicalExpression } from '../utils/nodes';
import { createEslintRule } from '../utils/rule';

export const RULE_NAME = 'cognitive-complexity';
export type MessageIds = 'fileComplexity' | 'refactorFunction' | 'vinicuncaRuntime';
type Options = ('metric' | 'vinicunca-runtime' | number)[];

const DEFAULT_THRESHOLD = 15;

type LoopStatement =
  | TSESTree.DoWhileStatement
  | TSESTree.ForInStatement
  | TSESTree.ForOfStatement
  | TSESTree.ForStatement
  | TSESTree.WhileStatement;

type OptionalLocation = TSESTree.SourceLocation | null | undefined;

const message
  = 'Refactor this function to reduce its Cognitive Complexity from {{complexityAmount}} to the {{threshold}} allowed.';

export default createEslintRule<Options, MessageIds>({
  create(context) {
    const threshold
      = typeof context.options[0] === 'number' ? context.options[0] : DEFAULT_THRESHOLD;
    const isFileComplexity = context.options.includes('metric');

    /** Complexity of the file */
    let fileComplexity = 0;

    /** Complexity of the current function if it is *not* considered nested to the first level function */
    let complexityIfNotNested: ComplexityPoint[] = [];

    /** Complexity of the current function if it is considered nested to the first level function */
    let complexityIfNested: ComplexityPoint[] = [];

    /** Current nesting level (number of enclosing control flow statements and functions) */
    let nesting = 0;

    /** Indicator if the current top level function has a structural (generated by control flow statements) complexity */
    let topLevelHasStructuralComplexity = false;

    /** Indicator if the current top level function is React functional component */
    const reactFunctionalComponent = {
      init(node: TSESTree.FunctionLike) {
        this.nameStartsWithCapital = nameStartsWithCapital(node);
        this.returnsJsx = false;
      },
      isConfirmed() {
        return this.nameStartsWithCapital && this.returnsJsx;
      },

      nameStartsWithCapital: false,

      returnsJsx: false,
    };

    /** Own (not including nested functions) complexity of the current top function */
    let topLevelOwnComplexity: ComplexityPoint[] = [];

    /** Nodes that should increase nesting level  */
    const nestingNodes: Set<TSESTree.Node> = new Set();

    /** Set of already considered (with already computed complexity) logical expressions */
    const consideredLogicalExpressions: Set<TSESTree.Node> = new Set();

    /** Stack of enclosing functions */
    const enclosingFunctions: TSESTree.FunctionLike[] = [];

    let secondLevelFunctions: Array<{
      complexityIfNested: ComplexityPoint[];
      complexityIfThisSecondaryIsTopLevel: ComplexityPoint[];
      loc: OptionalLocation;
      node: TSESTree.FunctionLike;
      parent: TSESTree.Node | undefined;
    }> = [];

    return {
      '*': function(node: TSESTree.Node) {
        if (nestingNodes.has(node)) {
          nesting++;
        }
      },
      '*:exit': function(node: TSESTree.Node) {
        if (nestingNodes.has(node)) {
          nesting--;
          nestingNodes.delete(node);
        }
      },

      ':function': (node: TSESTree.Node) => {
        onEnterFunction(node as TSESTree.FunctionLike);
      },
      ':function:exit': function(node: TSESTree.Node) {
        onLeaveFunction(node as TSESTree.FunctionLike);
      },
      BreakStatement(node: TSESTree.Node) {
        visitContinueOrBreakStatement(node as TSESTree.BreakStatement);
      },
      CatchClause(node: TSESTree.Node) {
        visitCatchClause(node as TSESTree.CatchClause);
      },

      ConditionalExpression(node: TSESTree.Node) {
        visitConditionalExpression(node as TSESTree.ConditionalExpression);
      },
      ContinueStatement(node: TSESTree.Node) {
        visitContinueOrBreakStatement(node as TSESTree.ContinueStatement);
      },
      DoWhileStatement(node: TSESTree.Node) {
        visitLoop(node as TSESTree.DoWhileStatement);
      },
      ForInStatement(node: TSESTree.Node) {
        visitLoop(node as TSESTree.ForInStatement);
      },
      ForOfStatement(node: TSESTree.Node) {
        visitLoop(node as TSESTree.ForOfStatement);
      },
      ForStatement(node: TSESTree.Node) {
        visitLoop(node as TSESTree.ForStatement);
      },
      IfStatement(node: TSESTree.Node) {
        visitIfStatement(node as TSESTree.IfStatement);
      },
      LogicalExpression(node: TSESTree.Node) {
        visitLogicalExpression(node as TSESTree.LogicalExpression);
      },
      Program() {
        fileComplexity = 0;
      },
      'Program:exit': function(node: TSESTree.Node) {
        if (isFileComplexity) {
          // value from the message will be saved in SonarQube as file complexity metric
          context.report({
            data: { complexityAmount: fileComplexity },
            messageId: 'fileComplexity',
            node,
          });
        }
      },
      ReturnStatement(node: TSESTree.Node) {
        visitReturnStatement(node as TSESTree.ReturnStatement);
      },
      SwitchStatement(node: TSESTree.Node) {
        visitSwitchStatement(node as TSESTree.SwitchStatement);
      },
      WhileStatement(node: TSESTree.Node) {
        visitLoop(node as TSESTree.WhileStatement);
      },
    };

    function onEnterFunction(node: TSESTree.FunctionLike) {
      if (enclosingFunctions.length === 0) {
        // top level function
        topLevelHasStructuralComplexity = false;
        reactFunctionalComponent.init(node);
        topLevelOwnComplexity = [];
        secondLevelFunctions = [];
      } else if (enclosingFunctions.length === 1) {
        // second level function
        complexityIfNotNested = [];
        complexityIfNested = [];
      } else {
        nesting++;
        nestingNodes.add(node);
      }
      enclosingFunctions.push(node);
    }

    function onLeaveFunction(node: TSESTree.FunctionLike) {
      enclosingFunctions.pop();
      if (enclosingFunctions.length === 0) {
        // top level function
        if (topLevelHasStructuralComplexity && !reactFunctionalComponent.isConfirmed()) {
          let totalComplexity = topLevelOwnComplexity;
          secondLevelFunctions.forEach((secondLevelFunction) => {
            totalComplexity = totalComplexity.concat(secondLevelFunction.complexityIfNested);
          });
          checkFunction(totalComplexity, getMainFunctionTokenLocation(node, node.parent, context));
        } else {
          checkFunction(
            topLevelOwnComplexity,
            getMainFunctionTokenLocation(node, node.parent, context),
          );
          secondLevelFunctions.forEach((secondLevelFunction) => {
            checkFunction(
              secondLevelFunction.complexityIfThisSecondaryIsTopLevel,
              getMainFunctionTokenLocation(
                secondLevelFunction.node,
                secondLevelFunction.parent,
                context,
              ),
            );
          });
        }
      } else if (enclosingFunctions.length === 1) {
        // second level function
        secondLevelFunctions.push({
          complexityIfNested,
          complexityIfThisSecondaryIsTopLevel: complexityIfNotNested,
          loc: getMainFunctionTokenLocation(node, node.parent, context),
          node,
          parent: node.parent,
        });
      } else {
        // complexity of third+ level functions is computed in their parent functions
        // so we never raise an issue for them
      }
    }

    function visitIfStatement(ifStatement: TSESTree.IfStatement) {
      const { parent } = ifStatement;
      const { loc: ifLoc } = getFirstToken(ifStatement, context);
      // if the current `if` statement is `else if`, do not count it in structural complexity
      if (isIfStatement(parent) && parent.alternate === ifStatement) {
        addComplexity(ifLoc);
      } else {
        addStructuralComplexity(ifLoc);
      }

      // always increase nesting level inside `then` statement
      nestingNodes.add(ifStatement.consequent);

      // if `else` branch is not `else if` then
      // - increase nesting level inside `else` statement
      // - add +1 complexity
      if (ifStatement.alternate && !isIfStatement(ifStatement.alternate)) {
        nestingNodes.add(ifStatement.alternate);
        const elseTokenLoc = getFirstTokenAfter(ifStatement.consequent, context)!.loc;
        addComplexity(elseTokenLoc);
      }
    }

    function visitLoop(loop: LoopStatement) {
      addStructuralComplexity(getFirstToken(loop, context).loc);
      nestingNodes.add(loop.body);
    }

    function visitSwitchStatement(switchStatement: TSESTree.SwitchStatement) {
      addStructuralComplexity(getFirstToken(switchStatement, context).loc);
      for (const switchCase of switchStatement.cases) {
        nestingNodes.add(switchCase);
      }
    }

    function visitContinueOrBreakStatement(
      statement: TSESTree.BreakStatement | TSESTree.ContinueStatement,
    ) {
      if (statement.label) {
        addComplexity(getFirstToken(statement, context).loc);
      }
    }

    function visitCatchClause(catchClause: TSESTree.CatchClause) {
      addStructuralComplexity(getFirstToken(catchClause, context).loc);
      nestingNodes.add(catchClause.body);
    }

    function visitConditionalExpression(conditionalExpression: TSESTree.ConditionalExpression) {
      const questionTokenLoc = getFirstTokenAfter(conditionalExpression.test, context)!.loc;
      addStructuralComplexity(questionTokenLoc);
      nestingNodes.add(conditionalExpression.consequent);
      nestingNodes.add(conditionalExpression.alternate);
    }

    function visitReturnStatement({ argument }: TSESTree.ReturnStatement) {
      // top level function
      if (
        enclosingFunctions.length === 1
        && argument
        && ['JSXElement', 'JSXFragment'].includes(argument.type as any)
      ) {
        reactFunctionalComponent.returnsJsx = true;
      }
    }

    function nameStartsWithCapital(node: TSESTree.FunctionLike) {
      const checkFirstLetter = (name: string) => {
        const firstLetter = name[0];
        return firstLetter === firstLetter.toUpperCase();
      };

      if (!isArrowFunctionExpression(node) && node.id) {
        return checkFirstLetter(node.id.name);
      }

      const { parent } = node;
      if (parent && parent.type === 'VariableDeclarator' && parent.id.type === 'Identifier') {
        return checkFirstLetter(parent.id.name);
      }

      return false;
    }

    function visitLogicalExpression(logicalExpression: TSESTree.LogicalExpression) {
      const jsxShortCircuitNodes = getJsxShortCircuitNodes(logicalExpression);
      if (jsxShortCircuitNodes != null) {
        jsxShortCircuitNodes.forEach((node) => {
          consideredLogicalExpressions.add(node);
        });

        return;
      }

      if (!consideredLogicalExpressions.has(logicalExpression)) {
        const flattenedLogicalExpressions = flattenLogicalExpression(logicalExpression);

        let previous: TSESTree.LogicalExpression | undefined;
        for (const current of flattenedLogicalExpressions) {
          if (!previous || previous.operator !== current.operator) {
            const operatorTokenLoc = getFirstTokenAfter(current.left, context)!.loc;
            addComplexity(operatorTokenLoc);
          }
          previous = current;
        }
      }
    }

    function flattenLogicalExpression(node: TSESTree.Node): TSESTree.LogicalExpression[] {
      if (isLogicalExpression(node)) {
        consideredLogicalExpressions.add(node);
        return [
          ...flattenLogicalExpression(node.left),
          node,
          ...flattenLogicalExpression(node.right),
        ];
      }
      return [];
    }

    function addStructuralComplexity(location: TSESTree.SourceLocation) {
      const added = nesting + 1;
      const complexityPoint = { complexity: added, location };
      if (enclosingFunctions.length === 0) {
        // top level scope
        fileComplexity += added;
      } else if (enclosingFunctions.length === 1) {
        // top level function
        topLevelHasStructuralComplexity = true;
        topLevelOwnComplexity.push(complexityPoint);
      } else {
        // second+ level function
        complexityIfNested.push({ complexity: added + 1, location });
        complexityIfNotNested.push(complexityPoint);
      }
    }

    function addComplexity(location: TSESTree.SourceLocation) {
      const complexityPoint = { complexity: 1, location };
      if (enclosingFunctions.length === 0) {
        // top level scope
        fileComplexity += 1;
      } else if (enclosingFunctions.length === 1) {
        // top level function
        topLevelOwnComplexity.push(complexityPoint);
      } else {
        // second+ level function
        complexityIfNested.push(complexityPoint);
        complexityIfNotNested.push(complexityPoint);
      }
    }

    function checkFunction(complexity: ComplexityPoint[] = [], loc: TSESTree.SourceLocation) {
      const complexityAmount = complexity.reduce((acc, cur) => acc + cur.complexity, 0);
      fileComplexity += complexityAmount;
      if (isFileComplexity) {
        return;
      }
      if (complexityAmount > threshold) {
        const secondaryLocations: IssueLocation[] = complexity.map((complexityPoint) => {
          const { complexity, location } = complexityPoint;
          const message
            = complexity === 1 ? '+1' : `+${complexity} (incl. ${complexity - 1} for nesting)`;
          return issueLocation(location, undefined, message);
        });

        report(
          context,
          {
            data: {
              complexityAmount,
              threshold,
            },
            loc,
            messageId: 'refactorFunction',
          },
          secondaryLocations,
          message,
          complexityAmount - threshold,
        );
      }
    }
  },

  defaultOptions: [DEFAULT_THRESHOLD],

  meta: {
    docs: {
      description: 'Cognitive Complexity of functions should not be too high',
      recommended: 'recommended',
    },
    messages: {
      fileComplexity: '{{complexityAmount}}',
      refactorFunction: message,
      vinicuncaRuntime: '{{vinicuncaRuntimeData}}',
    },
    schema: [
      { minimum: 0, type: 'integer' },
      {
        // internal parameter
        enum: ['vinicunca-runtime', 'metric'],
      } as any,
    ],
    type: 'suggestion',
  },

  name: RULE_NAME,
});

interface ComplexityPoint {
  complexity: number;
  location: TSESTree.SourceLocation;
}
